<!DOCTYPE html>
<head>
    <title>WebGL Pixels</title>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
    <meta name="apple-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
    
    body {
        margin: 0;
        margin-top: 0px;
        background-color: black;
        overflow-x: hidden;
        overflow-y: hidden;
    }
        
    #display {
        margin: 0px;
        width: 576px;
        height: 480px;
        background-color: rgb(50, 50, 50);
        image-rendering: -moz-crisp-edges;
        image-rendering: pixelated;
    }
    
    #controls {
        margin: 0px;
        width: 576px;
        height: 1px;
        background-color: rgb(10, 10, 100);
        image-rendering: -moz-crisp-edges;
        image-rendering: pixelated;
        
        z-index: 0;
        position: absolute;
        left: 0px;
        top: 0px;
    }
    
    #concon {
        width: 100%;
        height: 100%;
        position: relative;
    }
    
    #conarrows {
        background-color: rgba(255, 0, 0, 0.2);
        z-index: 1;
        position: absolute;
        left: 0px;
        top: 0px;
    }
    
    #conbuttons {
        background-color: rgba(255, 255, 0, 0.2);
        z-index: 1;
        position: absolute;
        left: 0px;
        top: 0px;
    }
    </style>
</head>
<body>

<div id="container" align="center" style="margin: 0px">
    <canvas id="display" width="192" height="160"></canvas>

    <div id="concon">
        <canvas id="controls" width="576" height="1"></canvas>
        <div id="conarrows"></div>
        <div id="conbuttons"></div>
    </div>
</div>

<script id="vertex_shader" type="x-shader/x-vertex">
attribute vec2 aPosition;
attribute vec4 aColor;

uniform vec2 uResolution;

varying vec4 vColor;
varying float y;

void main() {
    vec2 acPosition = vec2(aPosition.x + 0.5, aPosition.y + 0.5);
    vec2 clipSpace = (acPosition / uResolution * 2.0 - 1.0) * vec2(1.0, -1.0);
    y = (clipSpace.y + 1.0) / 2.0;
    gl_PointSize = 1.0;
    gl_Position = vec4(clipSpace, 0, 1);
    vColor = aColor;
}
</script>

<script id="fragment_shader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;
varying float y;

void main() {
    gl_FragColor = vec4(vColor.r, vColor.g, vColor.b, vColor.a * y);
}
</script>

<script src="update.js"></script>
<script>
var container = document.getElementById("container");
var conarrows = document.getElementById("conarrows");
var conbuttons = document.getElementById("conbuttons");
var controls = document.getElementById("controls");
var canvas = document.getElementById("display");
var gl = canvas.getContext("webgl", {
    //alpha: false,
    premultipliedAlpha: false,
    antialias: false,
    preserveDrawingBuffer: false
});

var vertexShaderSource = document.getElementById("vertex_shader").innerHTML;
var fragmentShaderSource = document.getElementById("fragment_shader").innerHTML;

var vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

var program = createProgram(vertexShader, fragmentShader);

gl.useProgram(program);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

var positionAttributeLocation = gl.getAttribLocation(program, "aPosition");
var colorAttributeLocation = gl.getAttribLocation(program, "aColor");
var resolutionUniformLocation = gl.getUniformLocation(program, "uResolution");

gl.enableVertexAttribArray(positionAttributeLocation);
gl.enableVertexAttribArray(colorAttributeLocation);
gl.enableVertexAttribArray(resolutionUniformLocation);

gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

var vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.UNSIGNED_BYTE, false, 6 * 1, 0);
gl.vertexAttribPointer(colorAttributeLocation, 4, gl.UNSIGNED_BYTE, true, 6 * 1, 2 * 1);

function createShader(type, source) {
    var shader = gl.createShader(type);
    
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(vertexShader, fragmentShader) {
    var program = gl.createProgram();
    
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

var globalColor = [255, 128, 0, 255];

var wb = canvas.width;
var hb = canvas.height;
var gridsize = wb * hb;
var gridbuffer = new Uint8ClampedArray(gridsize * 6);

var x = 10;
var y = 10;

var pcount = 0;

var worker;

function loop() {
    //pcount = 0;
    
    var data = {
        buffer: gridbuffer,
        keyboard: keyboard
    };
    
    worker.postMessage(data, [data.buffer.buffer]);
    
    //update();
    
    //render();
    
    //console.log(pcount);
    
    //requestAnimationFrame(loop);
}


function render() {
    //gl.clearColor(0, 0, 0, 0);
    //gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.bufferData(gl.ARRAY_BUFFER, gridbuffer, gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.POINTS, 0, gridsize);
    
}


var ENTER = "13";
var SPACE = "32";
var LEFT = "37";
var UP = "38";
var RIGHT = "39";
var DOWN = "40";

var keyboard = {
    "13": false,
    "32": false,
    "37": false,
    "38": false,
    "39": false,
    "40": false,
};

var moving = false;

window.onkeydown = function (event) {
    var key = event.which || event.keyCode;
    
    event.preventDefault();
    
    keyboard[key] = true;
};

window.onkeyup = function (event) {
    var key = event.which || event.keyCode;
    
    event.preventDefault();
    
    keyboard[key] = false;
};

var WIDTH_RATIO = 1;
var HEIGHT_RATIO = 1;

function goResize() {
    var w = window.innerWidth;
    var h = window.innerHeight;
    var c = canvas;
    var sw = c.width;
    var sh = c.height;
    
    var r = w / h;
    var sr = sw / sh;
    
    if (r > sr) {
        sw *= h / sh;
        sh = h;
    } else {
        sh *= w / sw;
        sw = w;
    }
    
    WIDTH_RATIO = c.width / sw;
    HEIGHT_RATIO = c.height / sh;
    
    c.style.width = Math.floor(sw) + "px";
    c.style.height = Math.floor(sh) + "px";
    
    var t = controls;
    t.width = Math.floor(sw);
    t.style.width = t.width + "px";
    t.height = Math.floor(h - Math.floor(sh));
    t.style.height = t.height + "px";
    
    var sh = 25;
    
    conarrows.style.width = (t.width / 2 + sh) + "px";
    conarrows.style.height = t.height + "px";
    
    conbuttons.style.width = (t.width / 2 - sh) + "px";
    conbuttons.style.height = t.height + "px";
    conbuttons.style.left = (t.width / 2 + sh) + "px";
    
    container.style.marginTop = "0px";//Math.floor((h - sh) / 2) + "px";
    
    renderControls();
}

var marginButtonHor = 3.5;
var marginButtonVer = 2;
var buttonSize = 40;

function ArrowButton(direction) {
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this.direction = direction;
    
    this.update = function () {
        var w = controls.width;
        var h = controls.height;
        var ax = w / marginButtonHor;
        var ay = h / marginButtonVer;
        var ar = 50;
        var as = buttonSize;
        
        this.w = as;
        this.h = as;
        
        switch (direction) {
            case "left":
                this.x = ax - ar - as/2;
                this.y = ay - as/2;
                break;
                
            case "up":
                this.x = ax - as/2;
                this.y = ay - ar - as/2;
                break;
                
            case "right":
                this.x = ax + ar - as/2;
                this.y = ay - as/2;
                break;
                
            case "down":
                this.x = ax - as/2;
                this.y = ay + ar - as/2;
                break;
        }
    };
    
    this.render = function (ctx) {
        this.update();
        
        ctx.strokeStyle = "red";
        ctx.lineWidth = 4;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
    };
    
    this.touching = function (x, y) {
        return this.x <= x && x < this.x + this.w && this.y <= y && y < this.y + this.h;
    };
    
    this.update();
}

function ActionButton(type) {
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this.type = type;
    
    this.update = function () {
        var w = controls.width;
        var h = controls.height;
        var ax = w - w / marginButtonHor + 5;
        var ay = h / marginButtonVer;
        var ar = 35;
        var as = buttonSize + 10;
        
        this.w = as;
        this.h = as;
        
        switch (type) {
            case "0":
                this.x = ax + ar;
                this.y = ay - ar/2;
                break;
                
            case "1":
                this.x = ax - ar;
                this.y = ay + ar/2;
                break;
        }
    };
    
    this.render = function (ctx) {
        this.update();
        
        ctx.fillStyle = this.type === "0" ? "yellow" : "lime";
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        ctx.font = "bold 24px monospace";
        ctx.fillStyle = "black";
        ctx.fillText(this.type, this.x + 18, this.y + 33);
    };
    
    this.touching = function (x, y) {
        return this.x <= x && x < this.x + this.w && this.y <= y && y < this.y + this.h;
    };
    
    this.update();
}

var leftArrow = new ArrowButton("left");
var rightArrow = new ArrowButton("right");
var downArrow = new ArrowButton("down");
var upArrow = new ArrowButton("up");

var buttonZero = new ActionButton("0");
var buttonOne = new ActionButton("1");

var controlCtx = controls.getContext("2d");
function renderControls() {
    var ctx = controlCtx;
    
    var w = controls.width;
    var h = controls.height;
    
    ctx.clearRect(0, 0, w, h);
    
    leftArrow.render(ctx);
    rightArrow.render(ctx);
    downArrow.render(ctx);
    upArrow.render(ctx);
    
    buttonZero.render(ctx);
    buttonOne.render(ctx);
    
    var w = controls.width;
    var h = controls.height;
    var cx = w / marginButtonHor;
    var cy = h / marginButtonVer;
    
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, 30, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(cx, cy, 100, 0, 2 * Math.PI);
    ctx.stroke();
}
//renderControls();

window.onresize = goResize;
goResize();

var CW_RATIO = 1;
var CH_RATIO = 1;


var touchStartHandler = function (event) {
    var rect = controls.getBoundingClientRect();
    var touch = event.targetTouches[0];
    
    //event.stopPropagation();
    event.preventDefault();
    
    var mouseX = (touch.pageX - window.pageXOffset - rect.left) * CW_RATIO;
    var mouseY = (touch.pageY - window.pageYOffset - rect.top) * CH_RATIO;
    
    //if (mouseX > controls.width / 2) return;
    
    keyboard[RIGHT] = false;
    keyboard[LEFT] = false;
    keyboard[UP] = false;
    keyboard[DOWN] = false;
    
    var key = "";
    
    var w = controls.width;
    var h = controls.height;
    var cx = w / marginButtonHor;
    var cy = h / marginButtonVer;
    var mx = mouseX;
    var my = mouseY;
    
    var dis = Math.sqrt((mx - cx) * (mx - cx) + (my - cy) * (my - cy));
    var dir = (-Math.atan2(my - cy, mx - cx) * 180 / Math.PI + 360) % 360;
    
    
    if (30 < dis && dis < 100) {
        if (dir < 45 || 315 <= dir) {
            key = RIGHT;
        }
        else if (45 <= dir && dir < 135) {
            key = UP;
        }
        else if (135 <= dir && dir < 225) {
            key = LEFT;
        }
        else if (225 <= dir && dir < 315) {
            key = DOWN;
        }
    }
    
    
    if (key) {
        keyboard[key] = true;
    }
};


var touchEndHandler = function (event) { 
    keyboard[RIGHT] = false;
    keyboard[LEFT] = false;
    keyboard[UP] = false;
    keyboard[DOWN] = false;
};

var touchCancelHandler = touchEndHandler;

var touchMoveHandler = touchStartHandler;

conarrows.addEventListener("touchstart", touchStartHandler);
conarrows.addEventListener("touchend", touchEndHandler);
conarrows.addEventListener("touchcancel", touchCancelHandler);
conarrows.addEventListener("touchmove", touchMoveHandler);





var touchStartHandler2 = function (event) {
    var rect = controls.getBoundingClientRect();
    var touch = event.targetTouches[0];
    
    //event.stopPropagation();
    event.preventDefault();
    
    var mouseX = (touch.pageX - window.pageXOffset - rect.left) * CW_RATIO;
    var mouseY = (touch.pageY - window.pageYOffset - rect.top) * CH_RATIO;
    
    //if (mouseX < controls.width / 2) return;
    
    keyboard[ENTER] = false;
    keyboard[SPACE] = false;
    
    var key = "";
    
    if (buttonZero.touching(mouseX, mouseY)) {
        key = ENTER;
    }
    
    if (buttonOne.touching(mouseX, mouseY)) {
        key = SPACE;
    }
    
    if (key) {
        keyboard[key] = true;
    }
};


var touchEndHandler2 = function (event) {
    keyboard[ENTER] = false;
    keyboard[SPACE] = false;
};

var touchCancelHandler2 = touchEndHandler2;

var touchMoveHandler2 = touchStartHandler2;

conbuttons.addEventListener("touchstart", touchStartHandler2);
conbuttons.addEventListener("touchend", touchEndHandler2);
conbuttons.addEventListener("touchcancel", touchCancelHandler2);
conbuttons.addEventListener("touchmove", touchMoveHandler2);


window.onload = function () {
    worker = new Worker("update.js");
    
    worker.onmessage = function (m) {
        gridbuffer = new Uint8Array(m.data);
        
        render();
        
        requestAnimationFrame(loop);
    };

    loop();
};
</script>

</body>
</html>