<!DOCTYPE html>
<head>
    <title>WebGL Pixels</title>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
    <meta name="apple-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
    
    body {
        margin: 0;
        margin-top: 0px;
        background-color: black;
        overflow-x: hidden;
        overflow-y: hidden;
    }
        
    #display {
        margin: 0px;
        width: 576px;
        height: 480px;
        background-color: rgb(50, 50, 50);
        image-rendering: -moz-crisp-edges;
        image-rendering: pixelated;
    }
    
    </style>
</head>
<body>

<div id="container" align="center" style="margin: 0px">
<canvas id="display" width="192" height="160"></canvas>
</div>

<script id="vertex_shader" type="x-shader/x-vertex">
attribute vec2 aPosition;
attribute vec4 aColor;

uniform vec2 uResolution;

varying vec4 vColor;
varying float y;

void main() {
    vec2 clipSpace = (aPosition / uResolution * 2.0 - 1.0) * vec2(1.0, -1.0);
    y = (clipSpace.y + 1.0) / 2.0;
    gl_PointSize = 1.0;
    gl_Position = vec4(clipSpace, 0, 1);
    vColor = aColor / 255.0;
}
</script>

<script id="fragment_shader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;
varying float y;

void main() {
    gl_FragColor = vec4(vColor.r, vColor.g, vColor.b, vColor.a);
}
</script>

<script src="update.js"></script>
<script>
var container = document.getElementById("container");
var canvas = document.getElementById("display");
var gl = canvas.getContext("webgl", {
    //alpha: false,
    premultipliedAlpha: false,
    antialias: false,
    preserveDrawingBuffer: false
});

var vertexShaderSource = document.getElementById("vertex_shader").innerHTML;
var fragmentShaderSource = document.getElementById("fragment_shader").innerHTML;

var vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

var program = createProgram(vertexShader, fragmentShader);

gl.useProgram(program);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

var positionAttributeLocation = gl.getAttribLocation(program, "aPosition");
var colorAttributeLocation = gl.getAttribLocation(program, "aColor");
var resolutionUniformLocation = gl.getUniformLocation(program, "uResolution");

gl.enableVertexAttribArray(positionAttributeLocation);
gl.enableVertexAttribArray(colorAttributeLocation);
gl.enableVertexAttribArray(resolutionUniformLocation);

gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

var vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 6 * 4, 0);
gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 6 * 4, 2 * 4);

function createShader(type, source) {
    var shader = gl.createShader(type);
    
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

function createProgram(vertexShader, fragmentShader) {
    var program = gl.createProgram();
    
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}

var globalColor = [255, 128, 0, 255];

var wb = canvas.width;
var hb = canvas.height;
var gridsize = wb * hb;
var gridbuffer = new Float32Array(gridsize * 6);

function setb(x, y, r, g, b, a) {
    if (x < 0 || wb <= x || y < 0 || hb <= y) return;
    
    var i = (x + y * wb) * 6;
    
    gridbuffer[i + 0] = x + 0.5;
    gridbuffer[i + 1] = y + 0.5;
    gridbuffer[i + 2] = r | 0;
    gridbuffer[i + 3] = g | 0;
    gridbuffer[i + 4] = b | 0;
    gridbuffer[i + 5] = a | 0;
}

function render() {
    //gl.clearColor(0, 0, 0, 0);
    //gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.bufferData(gl.ARRAY_BUFFER, gridbuffer, gl.DYNAMIC_DRAW);
    gl.drawArrays(gl.POINTS, 0, gridsize);
    clearbuffer();
}

function clearbuffer() {
    var len = gridsize * 6;
    for (var i = 5; i < len; i += 6) {
        gridbuffer[i] = 0;
    }
}

var x = 10;
var y = 10;

var pcount = 0;

function loop() {
    pcount = 0;
    
    update();
    
    render();
    
    //console.log(pcount);
    
    requestAnimationFrame(loop);
}

function clear() {
    for (var i = 0; i < pixels.length; i += 1) {
        pixels[i] = 0 | 0;
    }
}

function drawPixel(x, y, color) {
    pcount += 1;
    
    color = color || globalColor;//[255, 128, 0, 255];
    setb(x, y, color[0], color[1], color[2], color[3]);
}

function setcolor(r, g, b) {
    globalColor = [Math.floor(r), Math.floor(g), Math.floor(b), 255];
}


function yLine(x, y1, y2) {
    // INEFFICIENT!
    for (var y = y1; y <= y2; y++) {
        drawPixel(x, y);
    }
}


function xLine(x1, x2, y) {
    for (var x = x1; x <= x2; x++) {
        drawPixel(x, y);
    }
}

function circleOutline(x, y, r) {
    var xx = Math.floor(r);
    var yy = 0;
    var d = 1 - xx;
    
    while (yy <= xx) {
        drawPixel(x + xx, y + yy);
        if (yy < xx) drawPixel(x + yy, y + xx);
        drawPixel(x - xx, y + yy);
        if (0 < yy && yy < xx) drawPixel(x - yy, y + xx);
        if (0 < yy) drawPixel(x - xx, y - yy);
        if (0 < yy && yy < xx) drawPixel(x - yy, y - xx);
        if (0 < yy && yy < xx) drawPixel(x + xx, y - yy);
        drawPixel(x + yy, y - xx);
        
        yy += 1;
        
        if (d <= 0) {
            d += 2 * yy + 1;
        } else {
            xx -= 1;
            d += 2 * (yy - xx) + 1;
        }
    }
}

function circleFill(x, y, r) {
    var xx = Math.floor(r);
    var yy = 0;
    var d = 1 - xx;
    var prevx = xx;
    
    while (yy <= xx) {
        yLine(x + yy, y - xx, y + xx);
        if (0 < yy) yLine(x - yy, y - xx, y + xx);
        
        if (d <= 0) {
            yy += 1;
            d += 2 * yy + 1;
        } else {
            if (yy < xx) {
                yLine(x + xx, y - yy, y + yy);
                yLine(x - xx, y - yy, y + yy);
            }
            
            xx -= 1;
            yy += 1;
            d += 2 * (yy - xx) + 1;
        }
    }
}

function rectfill(x, y, w, h) {
    for (var i = y, yh = y + h; i < yh; i++) {
        xLine(x, x + w, i);
    }
}

var LEFT = "37";
var UP = "38";
var RIGHT = "39";
var DOWN = "40";

var keyboard = {
    "37": false,
    "38": false,
    "39": false,
    "40": false,
};

var moving = false;

window.onkeydown = function (event) {
    var key = event.which || event.keyCode;
    
    event.preventDefault();
    
    keyboard[key] = true;
};

window.onkeyup = function (event) {
    var key = event.which || event.keyCode;
    
    event.preventDefault();
    
    keyboard[key] = false;
};


var mouseX = 0;
var mouseY = 0;

var touchStartHandler = function (event) {
    var rect = canvas.getBoundingClientRect();
    var button = 0;
    var touch = event.touches[0];
    
    event.stopPropagation();
    event.preventDefault();
    
    mouseX = (touch.pageX - window.pageXOffset - rect.left) * WIDTH_RATIO;
    mouseY = (touch.pageY - window.pageYOffset - rect.top) * HEIGHT_RATIO;
    
    var key = "";
    
    if (mouseX < canvas.width / 2) {
        if (mouseY < canvas.height / 2) {
            key = RIGHT;
        } else {
            key = DOWN;
        }
    } else {
        if (mouseY < canvas.height / 2) {
            key = UP;
        } else {
            key = LEFT;
        }
    }
    
    console.log(key);
    
    keyboard[key] = true;
};

var touchEndHandler = function (event) {
    var rect = canvas.getBoundingClientRect();
    var button = 0;
    
    keyboard[RIGHT] = false;
    keyboard[LEFT] = false;
    keyboard[UP] = false;
    keyboard[DOWN] = false;
};

var touchCancelHandler = touchEndHandler;

var touchMoveHandler = function (event) {
    var rect = canvas.getBoundingClientRect();
    var touch = event.touches[0];
    
    event.stopPropagation();
    event.preventDefault();
    
    mouseX = (touch.pageX - window.pageXOffset - rect.left) * WIDTH_RATIO;
    mouseY = (touch.pageY - window.pageYOffset - rect.top) * HEIGHT_RATIO;
};

window.addEventListener("touchstart", touchStartHandler, false);
window.addEventListener("touchend", touchEndHandler, false);
window.addEventListener("touchcancel", touchCancelHandler, false);
window.addEventListener("touchmove", touchMoveHandler, false);

var WIDTH_RATIO = 1;
var HEIGHT_RATIO = 1;

function goResize() {
    var w = window.innerWidth;
    var h = window.innerHeight;
    var c = canvas;
    var sw = c.width;
    var sh = c.height;
    
    var r = w / h;
    var sr = sw / sh;
    
    if (r > sr) {
        sw *= h / sh;
        sh = h;
    } else {
        sh *= w / sw;
        sw = w;
    }
    
    WIDTH_RATIO = c.width / sw;
    HEIGHT_RATIO = c.height / sh;
    
    c.style.width = Math.floor(sw) + "px";
    c.style.height = Math.floor(sh) + "px";
    container.style.marginTop = "0px";//Math.floor((h - sh) / 2) + "px";
}

function boyResize() {
    var w = window.innerWidth;
    var h = window.innerHeight;
    var c = canvas;
    var sw = c.width;
    var sh = c.height;
    
    sh *= w / sw;
    sw = w;
    
    WIDTH_RATIO = c.width / sw;
    HEIGHT_RATIO = c.height / sh;
    
    c.style.width = Math.floor(sw) + "px";
    c.style.height = Math.floor(sh) + "px";
    container.style.marginTop = "0px";//Math.floor((h - sh) / 2) + "px";
}

window.onresize = goResize;
goResize();

window.onload = loop;
</script>

</body>
</html>