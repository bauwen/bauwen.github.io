<!DOCTYPE html>
<head>
    <title>Drone Simulation</title>
    <meta charset="utf-8">
</head>
<body style="margin: 0px; overflow: hidden">

<div style="position: relative">
    <canvas id="display" width="640" height="480" style="position: absolute; left: 0; top: 0; z-index: 0; pointer-events: none"></canvas>
    <canvas id="hud" width="640" height="480" style="position: absolute; left: 0; top: 0; z-index: 1; pointer-events: none"></canvas>
</div>

<script src="three.js"></script>
<script>
var SHIFT = "16";
var LEFT = "37";
var UP = "38";
var RIGHT = "39";
var DOWN = "40";
var A = "65";
var D = "68";
var E = "69";
var F = "70";
var M = "77";
var P = "80";
var Q = "81";
var R = "82";
var S = "83";
var Z = "90";

var keyboard = {
    "16": false,
    "37": false,
    "38": false,
    "39": false,
    "40": false,
    "65": false,
    "68": false,
    "69": false,
    "70": false,
    "77": false,
    "80": false,
    "81": false,
    "82": false,
    "83": false,
    "90": false
};

window.onkeydown = function (event) {
    event.preventDefault();
    
    var key = event.which || event.keyCode;
    keyboard[key] = true;
};

window.onkeyup = function (event) {
    var key = event.which || event.keyCode;
    keyboard[key] = false;
};

var hud = document.getElementById("hud");
hud.width = window.innerWidth;
hud.height = window.innerHeight;

var xx, yy;
var ctx = hud.getContext("2d");
ctx.font = "16px sans-serif";

var anglePitch = 0;
var rangePitch = document.createElement("input");
rangePitch.type = "range";
rangePitch.max = "360";
rangePitch.min = "0";
rangePitch.step = "1";
rangePitch.value = "0";
rangePitch.autofocus = true;
rangePitch.oninput = function () {
    //drone.rotation.z = rangePitch.value / 180 * Math.PI;
    anglePitch = rangePitch.value / 180 * Math.PI;
};
document.body.appendChild(rangePitch);

var angleRoll = 0;
var rangeRoll = document.createElement("input");
rangeRoll.type = "range";
rangeRoll.max = "360";
rangeRoll.min = "0";
rangeRoll.step = "1";
rangeRoll.value = "0";
rangeRoll.autofocus = true;
rangeRoll.oninput = function () {
    //drone.rotation.x = rangeRoll.value / 180 * Math.PI;
    angleRoll = rangeRoll.value / 180 * Math.PI;
};
document.body.appendChild(rangeRoll);

// WebGL

var drone;

var canvas = document.getElementById("display");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

var WIDTH = canvas.width;
var HEIGHT = canvas.height;

var scene = new THREE.Scene();
//scene.background = new THREE.Color("rgb(0, 160, 160)");

var camera = new THREE.PerspectiveCamera(90, WIDTH / HEIGHT, 1, 2000);
camera.position.x = 450;
camera.position.y = 50;
camera.position.z = 200;

var eyeLeft = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 2000);
var eyeRight = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 1, 2000);

var renderer = new THREE.WebGLRenderer({canvas: display, antialias: true});
renderer.setSize(WIDTH, HEIGHT);

var floor = new THREE.Mesh(
    new THREE.PlaneGeometry(1000, 500),
    new THREE.MeshBasicMaterial({color: 0x888888, side: THREE.DoubleSide})
);
floor.rotation.x = Math.PI / 2;
scene.add(floor);

addBox(-500, 0, -250, 500, 100, -260, 0x00ff00);
addBox(-500, 0, 250, 500, 100, 260, 0x00ff00);
addBox(-500, 0, -250, -510, 100, 250, 0xff8888);
addBox(500, 0, -250, 510, 100, 250, 0xff8888);

addSphere(-300, 20, -100, 30, 0xff0000);
addCone(300, 20, 100, 20, 60, 0xaa00aa);

addSphere(0, 50, 1000, 5, 0xff0000, true);

// Wall with hole
addBox(-10, 0, -250, 10, 30, 250, 0xffff00);
addBox(-10, 70, -250, 10, 100, 250, 0xffff00);
addBox(-10, 30, -250, 10, 70, -20, 0xffff00);
addBox(-10, 30, 20, 10, 70, 250, 0xffff00);

addLight(1000, 100, 500, 0xFFFFFF, 0.5);
addLight(-1000, 100, -500, 0xFFFFFF, 0.5);
addLight(1000, 100, -500, 0xFFFFFF, 0.5);
addLight(-1000, 100, 500, 0xFFFFFF, 0.5);
addLight(0, 200, 0, 0xFFFFFF, 0.2);

var eyeballLeft = addSphere(0, 0, 0, 2, 0x0000ff);
var eyeballRight = addSphere(0, 0, 0, 2, 0x0000ff);

var droneWidth = 20;
var droneHeight = 5;
var droneDepth = 10;
drone = addBox(0, 0, 0, 20, 5, 10, 0xDDFF66);


// rotation.x = roll
// rotation.y = yaw
// rotation.z = pitch

drone.rotation.y = Math.PI;
drone.position.set(300, 50, 0);
drone.rotation.order = "YXZ";

var direction = 90;

var loop = function () {
    requestAnimationFrame(loop);
    updateSize();
    
    if (keyboard[Z]) {
        camera.position.x += Math.cos(direction / 180 * Math.PI) * 5;
        camera.position.z += -Math.sin(direction / 180 * Math.PI) * 5;
    }
    
    if (keyboard[S]) {
        camera.position.x -= Math.cos(direction / 180 * Math.PI) * 5;
        camera.position.z -= -Math.sin(direction / 180 * Math.PI) * 5;
    }
    
    camera.position.y += (keyboard[R] - keyboard[F]) * 2;
    
    direction += (keyboard[Q] - keyboard[D]) * 3;
    direction = (direction + 360) % 360;
    
    camera.lookAt(new THREE.Vector3(
        camera.position.x + Math.cos(direction / 180 * Math.PI), 
        camera.position.y, 
        camera.position.z - Math.sin(direction / 180 * Math.PI)
    ));
    
    
    // drone
    drone.rotation.x = angleRoll;
    drone.rotation.y += (keyboard[LEFT] - keyboard[RIGHT]) * 0.05;
    drone.rotation.z = anglePitch;
    
    if (keyboard[UP]) {
        drone.position.x += Math.cos(drone.rotation.y) * 5;
        drone.position.z += -Math.sin(drone.rotation.y)* 5;
    }
    
    if (keyboard[DOWN]) {
        drone.position.x -= Math.cos(drone.rotation.y) * 5;
        drone.position.z -= -Math.sin(drone.rotation.y)* 5;
    }
    
    drone.position.y += (keyboard[P] - keyboard[M]) * 2;
    
    // left eye
    eyeLeft.position.x = drone.position.x;
    eyeLeft.position.x += Math.cos(drone.rotation.y + Math.PI / 2) * droneDepth / 2;
    eyeLeft.position.x += Math.cos(drone.rotation.y) * droneWidth / 2;
    
    eyeLeft.position.z = drone.position.z;
    eyeLeft.position.z += -Math.sin(drone.rotation.y + Math.PI / 2) * droneDepth / 2;
    eyeLeft.position.z += -Math.sin(drone.rotation.y) * droneWidth / 2;
    
    eyeLeft.position.y = drone.position.y;
    
    eyeLeft.lookAt(new THREE.Vector3(
        eyeLeft.position.x + Math.cos(drone.rotation.y),
        eyeLeft.position.y,
        eyeLeft.position.z - Math.sin(drone.rotation.y)
    ));
    
    eyeballLeft.position.x = eyeLeft.position.x;
    eyeballLeft.position.y = eyeLeft.position.y;
    eyeballLeft.position.z = eyeLeft.position.z;
    
    // right eye
    eyeRight.position.x = drone.position.x;
    eyeRight.position.x += Math.cos(drone.rotation.y - Math.PI / 2) * droneDepth / 2;
    eyeRight.position.x += Math.cos(drone.rotation.y) * droneWidth / 2;
    
    eyeRight.position.z = drone.position.z;
    eyeRight.position.z += -Math.sin(drone.rotation.y - Math.PI / 2) * droneDepth / 2;
    eyeRight.position.z += -Math.sin(drone.rotation.y) * droneWidth / 2;
    
    eyeRight.position.y = drone.position.y;
    
    eyeRight.lookAt(new THREE.Vector3(
        eyeRight.position.x + Math.cos(drone.rotation.y),
        eyeRight.position.y,
        eyeRight.position.z - Math.sin(drone.rotation.y)
    ));
    
    eyeballRight.position.x = eyeRight.position.x;
    eyeballRight.position.y = eyeRight.position.y;
    eyeballRight.position.z = eyeRight.position.z;
    
    
    // render camera's
    var backgroundColor = 0x55dddd;
    render(camera, 0, 0, 0.498, 0.5, backgroundColor);
    render(eyeLeft, 0, 0.51, 0.498, 0.5, backgroundColor);
    render(eyeRight, 0.502, 0.51, 0.5, 0.5, backgroundColor);
};

loop();

function render(cam, l, b, w, h, col) {
    var left = Math.floor(WIDTH * l);
    var bottom = Math.floor(HEIGHT * b);
    var width = Math.floor(WIDTH * w);
    var height = Math.floor(HEIGHT * h);
    
    renderer.setViewport(left, bottom, width, height);
    renderer.setScissor(left, bottom, width, height);
    renderer.setScissorTest(true);
    renderer.setClearColor(col);
    
    cam.aspect = width / height;
    cam.updateProjectionMatrix();
    
    renderer.render(scene, cam);
}

function updateSize() {
    if (WIDTH != window.innerWidth || HEIGHT != window.innerHeight) {
        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;
        
        renderer.setSize(WIDTH, HEIGHT);
    }
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "black";
    ctx.fillText("Linkeroog", 20, 20);
    ctx.fillText("Rechteroog", 20 + window.innerWidth / 2, 20);
    ctx.fillText("Vrije camera", 20, 20 + window.innerHeight / 2);
    
    xx = 20 + window.innerWidth / 2 + 50;
    yy = 20 + window.innerHeight / 2 + 60;
    ctx.fillStyle = "white";
    ctx.fillText("Pitch (" + rangePitch.value + "°)", xx, yy - 20);
    rangePitch.style = "position: absolute; left: " + xx + "px; top: " + yy + "px";
    
    xx = 20 + window.innerWidth / 2 + 50;
    yy = 20 + window.innerHeight / 2 + 150;
    ctx.fillText("Roll (" + rangeRoll.value + "°)", xx, yy - 20);
    rangeRoll.style = "position: absolute; left: " + xx + "px; top: " + yy + "px";
    
    xx = 20 + window.innerWidth / 2 + 280;
    yy = 20 + window.innerHeight / 2 + 50;
    ctx.fillText("Drone beweging:", xx, yy);
    ctx.fillText("pijltjestoetsen & P en M", xx + 20, yy + 30);
    ctx.fillText("Vrije camera beweging:", xx, yy + 80);
    ctx.fillText("Z, Q, S, D & R en F", xx + 20, yy + 110);
}

function addBox(x1, y1, z1, x2, y2, z2, color) {
    var width = Math.abs(x2 - x1);
    var height = Math.abs(y2 - y1);
    var depth = Math.abs(z2 - z1);
    
    var box = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, depth),
        new THREE.MeshLambertMaterial({color: color})
    );
    box.position.x = Math.min(x1, x2) + width / 2;
    box.position.y = Math.min(y1, y2) + height / 2;
    box.position.z = Math.min(z1, z2) + depth / 2;
    
    scene.add(box);
    return box;
}

function addSphere(x, y, z, radius, color, basic) {
    var material;
    if (basic) {
        material = new THREE.MeshBasicMaterial({color: color});
    } else {
        material = new THREE.MeshLambertMaterial({color: color});
    }
    
    var sphere = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 16, 16),
        material
    );
    sphere.position.x = x;
    sphere.position.y = y;
    sphere.position.z = z;
    
    scene.add(sphere);
    return sphere;
}

function addCone(x, y, z, radius, height, color) {
    var cone = new THREE.Mesh(
        new THREE.ConeGeometry(radius, height, 16),
        new THREE.MeshLambertMaterial({color: color})
    );
    cone.position.x = x;
    cone.position.y = y;
    cone.position.z = z;
    
    scene.add(cone);
    return cone;
}

function addLight(x, y, z, color, intensity) {
    var light = new THREE.PointLight(color, intensity || 1.0);
    light.position.set(x, y, z);
    
    scene.add(light);
    return light;
}
</script>

</body>
</html>